---
layout: post
title: AI学习时间 09 - 指令微调与人类对齐
date: 2025-05-21
categories:
    - AI
tags:
    - AI
    - 学习
    - 指令微调
    - 人类对齐
    - 大语言模型训练
---

<div class="theme-color-blue" markdown=1>
`#指令微调` `#人类对齐` `#大语言模型训练流程`
</div>

# 复习

- **训练**：通过不断地尝试，来得到模型的参数。

    ```mermaid
    graph LR
        Data[训练数据] --> Model[模型]
        Model --> Output[模型输出]
        Target[期望输出] --> Loss[损失函数]
        Output --> Loss
        Loss --> Optimizer[优化器]
        Optimizer -->|更新参数| Model
    ```

- **参数**：大模型的参数就是权重矩阵（$\textbf{W}$）和偏置（$\textbf{b}$），参数量决定了模型的规模和能力
- **大语言模型**：是概率模型，预测给定上下文的下一个词，条件概率表示为 $p(w_1, \dots, w_m) = \prod^m_{t = 1} P(w_t | w_1, \dots, w_{t - 1})$。

# 预训练

大语言模型的预训练过程，就是猜测下一个词的过程，预训练之后的大模型，只具备猜测下一个词的能力。但我们平时使用的时候，是对大语言模型提出问题，所以预训练之后的大语言模型，我们通常称其为 **“基座”**。要进一步对基座进行训练，才能得到我们日常使用的大语言模型。

# 指令微调

**指令微调（Instruction Tuning）**是指使用自然语言形式的数据对预训练后的大语言模型进行参数微调，这一术语由谷歌研究员在 2022 年的一篇 ICLR 论文中正式提出。在另外一些参考文献中，指令微调也被称为有**监督微调（Supervised Fine-tuning）**或**多任务提示训练（Multitask Prompted Training）**。

指令微调过程分为两步

1. 首先收集或构建指令化的实例
2. 然后通过有监督的方式对大语言模型的参数进行微调

经过指令微调后，大语言模型能够展现出较强的指令遵循能力，可以通过零样本学习的方式解决多种下游任务。

## 指令数据的构建

既然要进行微调，那就得准备微调的数据。有几种方式可以进行指令数据的构建。

### 基于现有的 NLP 任务数据集构建

NLP 领域已经较为完善，市面上有比较多的 NLP 任务数据集，这些数据集里有多种 NLP 任务，比如机器翻译，文本摘要，文本分类等等。这些数据集的形式都是“提问 - 回答”的形式。比如机器翻译任务，其数据条目的形式为“英文 - 中文”，比如

> 输入：Large language models have become one important research direction for machine learning

> 输出：大语言模型已经成为机器学习的一个重要研究方向

理论上，我们可以用这种数据对模型基座进行进一步的训练，但是回忆之前提到的一点是，语言是人类社会沟通的基础，人类社会的各种行为，思想，逻辑均可以通过语言进行表述，在预训练的时候，大语言模型已经学会了这些内在逻辑，但是在外使用形式是“猜测下一个词”而已，所以指令微调旨在激发大语言模型的外在表达能力。于是指令构造必须也是使用自然语言进行表述，所以在构造指令数据集的时候，可以将上面的原始数据改为

> 输入：请将这个句子翻译为中文“Large language models have become one important research direction for machine learning”

> 输出：大语言模型已经成为机器学习的一个重要研究方向

两个输入之间最大的差别在于，后者增加了“自然语言的人类指令”。

### 基于日常对话的数据构建

尽管通过指令格式化已有的 NLP 数据集能够获得大量的指令数据实例，但是这些数据的多样性比较局限，与人类的真实需求也不能很好匹配。为此，研究人员开始使用用户在日常对话中的实际需求作为任务描述。

例如，InstructGPT 将用户提交给 OpenAI API 的查询作为任务描述。由于这些用户查询源自于真实应用场景，均采用自然语言形式进行表达，因此特别适合大模型学习指令跟随能力。为了进一步增加任务的多样性，OpenAI 还雇佣标注者创作更多的真实生活任务，包括开放式生成、开放式问答、头脑风暴等任务，然后由另一组标注者来回答这些问题作为输出。OpenAI 最终将指令（用户真实查询或者人工标注的任务）和期望的输出（人工编写的答案）配对作为一个训练实例。但是，OpenAI 没有对外开放所使用的指令数据。

### 基于合成数据构建

为了减轻人工收集与标注数据的负担，研究人员进一步提出半自动化的数据合成方法。他们借助已有的高质量指令数据作为上下文学习示例输入大语言模型，进而生成大量多样化的任务描述和输入-输出数据。

下面是交给大语言模型的 prompt 示例，用于让大语言模型生成多样化的任务指令。

> 你被要求提供10 个多样化的任务指令。这些任务指令将被提供给 GPT 模型。
> 以下是你提供指令需要满足的要求：
> 
> 1. 尽量不要在每个指令中重复动词，要最大化指令的多样性。
> 2. 使用指令的语气也应该多样化。例如，将问题与祈使句结合起来。
> ...（省略后续要求）
> 
> 下面是 10 个任务指令的列表：
> 
> \#\#\# 指令：将85 华氏度转换为摄氏度。 <br />
> \#\#\# 输出：85 华氏度等于29.44 摄氏度。 <br />
> \#\#\# 指令：是否有科学无法解释的事情？ <br />
> \#\#\# 输出：有很多科学无法解释的事情，比如生命的起源、意识的存在... <br />
> ...（省略上下文示例）

## 指令微调的作用

### 整体任务性能改进

指令微调旨在使用人工构建的指令数据对于大语言模型进一步训练，从而增强或解锁大语言模型的能力。

- 相关研究表明，不同规模的语言模型（参数量规模从77M 到540B）都可以从指令微调中受益，提升的性能随着参数规模的增加而提升。
- 经过指令微调的小模型甚至可以比没有经过微调的大模型表现得更出色，进一步凸显了指令微调的有效性。

同时，与预训练相比，指令微调的成本显著降低，大模型所需的指令数据量仅为预训练阶段的约万分之一甚至更少。

### 任务求解能力增强

指令微调旨在指导模型学会理解自然语言指令，并据此完成相应的任务。通过指令微调，大模型能够获得较好的指令遵循与任务求解能力，无需下游任务的训练样本或者示例就可以解决训练中未见过的任务。

### 领域专业化适配

通用的大语言模型能够在传统自然语言处理任务（如生成和推理）以及日常生活任务（如头脑风暴）上取得较好的效果，然而它们在特定领域中（如医学、法律和金融等）的表现与领域专用模型的效果仍有一定差距。在实际应用中，可以针对大语言模型进行面向特定领域的指令微调，从而使之能够适配下游的任务。

# 人类对齐

经过大规模的预训练和有监督指令微调，大语言模型具备了解决各种任务的通用能力和指令遵循能力，但是同时也可能生成有偏见的、冒犯的以及事实错误的文本内容。这些潜在的有害行为，可能在下游应用中产生严重的影响与危害，进一步被恶意使用者进行放大与利用。因此，在大语言模型的学习过程中，如何确保大语言模型的行为与人类价值观、人类真实意图和社会伦理相一致成为了一个关键研究问题，通常称这一研究问题为 **人类对齐（Human Alignment）**。

## 背景

在大语言模型的预训练和有监督微调的过程中，主要训练目标是根据上下文内容来预测下一个词元。但是，这一过程并未充分考虑人类的价值观或偏好，可能导致大语言模型从数据中学习到不符合人类期望的生成模式。为了规避这些潜在风险，研究人员提出了“人类对齐”这一关键概念，旨在保证大语言模型的行为与人类期望和价值观相一致。

## 对齐标准

人类对齐是一个较为抽象的概念，难以直接进行形式化建模，关于对齐的定义和标准也存在不同的观点。三个具有代表性的对齐标准是 **有用性（Helpfulness）**，**诚实性（Honesty）**和**无害性（Harmlessness）**。

### 有用性

在实际应用中，大语言模型需要提供有用的信息，能够准确完成任务，正确理解上下文，并展现出一定的创造性与多样性。模型应尽量以简洁、高效的方式协助用户完成任务。当任务描述存在歧义或涉及背景信息时，模型应具备主动询问并获取任务相关信息的能力，同时具有一定的敏感度、洞察力和审慎态度。

### 诚实性

模型的输出应具备真实性和客观性，不应夸大或歪曲事实，避免产生误导性陈述，并能够应对输入的多样性和复杂性。

### 无害性

大语言模型应避免生成可能引发潜在负面影响或危害的内容。在处理敏感主题时，模型应遵循道德标准和社会价值观，从而消除冒犯性与歧视性。此外，模型需要能够检测到具有恶意目的的查询请求。当模型被诱导执行危险行为（如犯罪行为）时，应直接予以拒绝。

## 基于人类反馈的强化学习

由于对齐标准难以通过形式化的优化目标进行建模，因此研究人员提出了 **基于人类反馈的强化学习（Reinforcement Learning from Human Feedback, RLHF）**，引入人类反馈对大语言模型的行为进行指导。

### RLHF 概述

RLHF 首先需要收集人类对于不同模型输出的偏好，然后使用收集到的人类反馈数据训练奖励模型，最后基于奖励模型使用强化学习算法（例如Proximal Policy Optimization, PPO）微调大语言模型。

### RLHF 算法系统

RLHF 算法系统主要包括三个关键组成部分：需要与**人类价值观对齐的模型**、**基于人类反馈数据学习的奖励模型**以及**用于训练大语言模型的强化学习算法**。

- 待对齐模型是指经过预训练，具备一定通用能力的大语言模型。
- 奖励模型的作用是为强化学习过程提供指导信号，反应了人类对于语言模型生成文本的偏好，通常以标量形式呈现。
- 在训练过程中，基于奖励模型提供的反馈信号，RLHF 使用特定的强化学习算法进行大语言模型的训练。目前，PPO 算法是一种被广泛应用于人类对齐的强化学习算法。

### RLHF 的关键步骤

下图展示了 RLHF 整体训练框架的三个阶段。

![](/assets/images/2025-05-21-AI学习-指令微调与人类对齐/rlhf.png)

- **监督微调**：为了让待对齐语言模型具有较好的指令遵循能力，通常需要收集高质量的指令数据进行监督微调。指令数据一般包括任务描述和示例输出，可以由人类标注员针对特定任务编写，也可以由大语言模型自动生成。
- **奖励模型训练**：先使用语言模型针对任务指令生成一定数量的候选输出。随后，邀请标注员对于输出文本进行偏好标注，这个标注过程可以采用多种形式，其中最常用的是对候选文本进行排序标注，这样可以有效减少多个标注员之间的不一致情况。进一步，使用人工标注的偏好数据进行奖励模型的训练。
- **强化学习训练**：语言模型对齐被转化为一个强化学习问题。具体来说，待对齐语言模型担任策略实施者的角色（称为策略模型），它接收提示作为输入并返回输出文本，其动作空间是词汇表中的所有词元，状态指的是当前已生成的词元序列。奖励模型则根据当前语言模型的状态提供相应的奖励分数，用于指导策略模型的优化。为了避免当前训练轮次的语言模型明显偏离初始（强化学习训练之前）的语言模型，通常会在原始优化目标中加入一个惩罚项（如KL散度）。

下面给出强化学习流程的伪代码，省略了比较多的细节，仅为了表达基础流程，方便理解。

```ts
const instructModel = new InstructModel()
const rewardModel = new RewardModel()
const data = prepareData()

const train = (instructModel, rewardModel) => {
  _.each(data, ask => {
    // 1. 使用待对齐模型生成输出
    const answer = instructModel.forward(ask)
    // 2. 人类反馈
    const score = rewardModel.forward(answer)
    // 3. 计算损失
    const loss = Loss(score, instructModel)
    // 4. 训练
    loss.update(instructModel)
  })
}
```

整个训练过程中，通过奖励模型不断对待对齐模型的输出进行评分，从而使得待对齐模型的输出尽量获得更高的分数，也就是更符合人类的偏好。

# 大语言模型训练流程总结

通过这段时间的学习，下面总结一下大语言模型整个训练流程。

1. **数据准备**：收集和准备用于训练的文本数据。这包括从互联网、书籍、新闻等来源获取文本数据，并进行清洗、分词等预处理。
2. **预训练**：使用大规模的文本数据对大语言模型进行预训练。这包括使用自回归模型（如GPT）对文本数据进行建模，学习语言的统计规律和语法知识。
3. **指令微调**：使用指令数据对预训练的大语言模型进行指令微调。这包括将指令数据与相应的输出文本配对，并使用有监督学习的方式对模型进行参数更新。
4. **人类对齐**：使用人类反馈对微调后的大语言模型进行对齐。这包括收集人类对模型输出的偏好，并使用强化学习算法对模型进行进一步的训练。

```ts
const data = prepareData()
const baseModel = preTrain(data)
const tunedModel = instructionTune(baseModel, instructionData)
const alignedModel = humanAlignment(tunedModel, humanFeedback)
```

回顾一下训练的流程，关键是寻找损失函数，然后通过调整参数来使得整体损失最小。

- 在预训练阶段，主要目标是对下一个词的猜测，所以损失函数是预测词与目标词的对比。
- 在指令微调阶段，主要目标是让大语言模型遵从指令来完成任务，所以损失函数是任务输出序列与期望输出序列的对比。
- 在人类对齐阶段，主要目标是让大语言模型的输出满足人类的偏好，所以奖励模型会对输出进行打分，损失函数就是奖励模型的打分。

```ts
const preTrainLoss = crossEntropyLoss(predictionWord, targetWord)
const instructionTuneLoss = crossEntropyLoss(answerSequence, expectedSequence)
const humanAlignmentLoss = rewardModelScore(answer) 
```

上面展示了损失函数的伪代码，从抽象的函数调用可以看到各损失函数计算距离的对象，基座训练阶段计算词与词，指令微调阶段计算序列到序列，人类对齐阶段直接使用奖励模型的打分。