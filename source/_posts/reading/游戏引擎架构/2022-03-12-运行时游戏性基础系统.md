---
layout: post
title: 运行时游戏性基础系统
date: 2022-03-12
tags:
    - 游戏引擎
    - 架构
---

# 游戏性基础系统的组件

多数游戏引擎都会带有一套运行时软件组件，它们合作提供一套框架实现游戏独特的规则，目标，动态世界元素。游戏业界对这些组件无标准命名，但我们把它们总称为引擎的**游戏性基础系统（gameplay foundation system）**。

每个游戏引擎的游戏性软件设计方法都有点不同，但多数引擎都会提供这些主要的子系统。

- **运行时游戏对象模型（runtime game object model）**：抽象游戏对象模型的实现，供游戏设计师在世界编辑器中使用。
    - **动态地产生及消灭游戏对象**：游戏对象随游戏性创建及消去。
    - **联系底层引擎系统**：每个游戏对象都会联系至一个或多个下层的引擎系统。
    - **实时模拟对象行为**：游戏引擎需要随时间更动态地更新所有游戏对象的状态。
    - **定义新游戏对象类型**：开发过程中，随着需求的变更，对象模型必须要有足够的弹性，可以容易地加入新的对象类型。
    - **唯一的对象标识符**：每个游戏对象都要有唯一的标识符。
    - **游戏对象查询**：提供各种方便的高级查询来查询任意的对象。
    - **游戏对象引用**：当找到了所需的对象，我们需要以某种机制保留其引用。
    - **有限状态机**：用状态机来控制游戏对象的状态。
    - **网络复制**：在多人游戏中，对象的状态也必须复制到其他人的机器中**。**
    - **存档及载入游戏，对象持久性**：将游戏对象的当前状态持久化到磁盘，供以后读入。
- **关卡管理及串流（level management and streaming）**：负责载入及释放游戏性用到的虚拟世界内容。
- **更新实时对象模型（realtime object model updating）**：领游戏世界中的游戏对象能有自主的行为，必须定期更新每个对象。
- **消息及事件处理（messaging and event handing）**：游戏对象之间或与游戏世界之间的通信。
- **脚本（scripting）**：用于编写高级的游戏逻辑。
- **目标及游戏流程管理（objectives and game flow management）**：此子系统管理玩家的目标及游戏的整体流程。

# 各种运行时对象模型架构

## 以对象为中心的各种架构

在以**对象为中心**的各种架构中，每个逻辑游戏对象会实现为类的实例，或一组相互链接的实例。

- 简单对象会造成对象爆炸。
- 简单集成会导致类型树过深。
- 多重集成会导致致命钻石。
- 行为混入，合成，聚合方式，就比较灵活。

![含 mix-in 类的类层次结构。任何继承 MHealth 的类会增加血量信息，并可以被杀。MCarryable 类可以令其派生类的对象被角色携带。](/assets/images/2022-03-12-运行时游戏性基础系统/架构.png)

含 mix-in 类的类层次结构。任何继承 MHealth 的类会增加血量信息，并可以被杀。MCarryable 类可以令其派生类的对象被角色携带。

## 以属性为中心的各种架构

我们先定义游戏对象可能含有的属性集合，然后为每个属性建表，每个表含有各个对象对应该属性的值，这些属性值以对象唯一标识符为键，这称为以**属性为中心的视图（property-centric view）**。

### 通过属性类实现行为

每个属性可以实现为属性类。属性可以是简单的单值，也可以是复杂到如一个渲染用的三角形网络。每个属性类可以通过成员函数来产生行为。某游戏对象的整体行为则是由其全部属性的行为集结而得。

### 通过脚本实现行为

把属性值以原始方式存储于一个或多个如数据库的表里，然后用脚本代码实现对象的行为。每个游戏对象可能含有一个名为 `ScriptId` 的特殊属性，若果对象含该属性，那么它就是用来指定管理对象行为的脚本部分。

<aside>
💡 **以属性为中心的设计的优缺点**

- 趋向于更有效地使用内存，因为只需存储实际上用到的属性。
- 更有效地使用数据驱动建模。
- 缓存更友好，因为相同类型的数据在内存中是连续存储的。

</aside>